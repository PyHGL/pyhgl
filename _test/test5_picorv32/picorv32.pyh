from pyhgl.logic import * 


@conf PicoConfig:
    DEBUGNETS = 0
    DEBUGREGS = 0 
    DEBUGASM = 0 
    DEBUG = 0 
    RISCV_FORMAL = 0 
    PICORV32_REGS = 0

    ENABLE_COUNTERS = 1
    ENABLE_COUNTERS64 = 1
    ENABLE_REGS_16_31 = 1
    ENABLE_REGS_DUALPORT = 1
    LATCHED_MEM_RDATA = 0
    TWO_STAGE_SHIFT = 1
    BARREL_SHIFTER = 0
    TWO_CYCLE_COMPARE = 0
    TWO_CYCLE_ALU = 0
    COMPRESSED_ISA = 0
    CATCH_MISALIGN = 1
    CATCH_ILLINSN = 1
    ENABLE_PCPI = 0
    ENABLE_MUL = 0
    ENABLE_FAST_MUL = 0
    ENABLE_DIV = 0
    ENABLE_IRQ = 0
    ENABLE_IRQ_QREGS = 1
    ENABLE_IRQ_TIMER = 1
    ENABLE_TRACE = 0
    REGS_INIT_ZERO = 0
    MASKED_IRQ = '32:h0'
    LATCHED_IRQ = '32:hffff_ffff'
    PROGADDR_RESET = '32:h0'
    PROGADDR_IRQ = '32:h0'
    STACKADDR = '32:hffff_ffff' 



@module Picorv32:
    @bundle io:
        trap = UInt(0) 
        # IRQ Interface 
        irq = UInt(0, w=32)
        eoi = UInt(0, w=32)
        @bundle mem:
            valid       = UInt(0)
            instr       = UInt(0)
            ready       = UInt(0)
            addr        = UInt(0, w=32)
            wdata       = UInt(0, w=32)
            wstrb       = UInt(0, w=4)
            # Look-Ahead Interface 
            la_read     = UInt(0)
            la_write    = UInt(0)
            la_addr     = UInt(0, w=32)
            la_wdata    = UInt(0, w=32)
            la_wstrb    = UInt(0, w=4)
        # Pico Co-Processor Interface (PCPI)
        @bundle pcpi:
            valid       = UInt(0)
            insn        = UInt(0, w=32)
            rs1         = UInt(0, w=32)
            rs2         = UInt(0, w=32)
            wr          = UInt(0)
            rd          = UInt(0, w=32)
            wait        = UInt(0)
            ready       = UInt(0)
        # Trace Interface 
        @bundle trace:
            valid   = UInt(0)
            data    = UInt(0, w=32) 

        if conf.p.RISCV_FORMAL:
            @bundle rvfi:
                valid   = UInt(0)
                order   = UInt(0, w=64)
                insn    = UInt(0, w=32)
                trap    = UInt(0)
                halt    = UInt(0)
                intr    = UInt(0)
                mode    = UInt(0, w=2)
                ixl     = UInt(0, w=2)
                rs1_addr    = UInt(0, w=5)
                rs2_addr    = UInt(0, w=5)
                rs1_rdata   = UInt(0, w=32)
                rs2_rdata   = UInt(0, w=32)
                rd_addr     = UInt(0, w=5)
                rd_wdata    = UInt(0, w=32)
                pc_rdata    = UInt(0, w=32)
                pc_wdata    = UInt(0, w=32)
                mem_addr    = UInt(0, w=32)
                mem_rmask   = UInt(0, w=4)
                mem_wmask   = UInt(0, w=4)
                mem_rdata   = UInt(0, w=32)
                mem_wdata   = UInt(0, w=32)
                csr_mcycle_rmask    = UInt(0, w=64)
                csr_mcycle_wmask    = UInt(0, w=64)
                csr_mcycle_rdata    = UInt(0, w=64)
                csr_mcycle_wdata    = UInt(0, w=64)
                csr_minstret_rmask  = UInt(0, w=64)
                csr_minstret_wmask  = UInt(0, w=64)
                csr_minstret_rdata  = UInt(0, w=64)
                csr_minstret_wdata  = UInt(0, w=64) 
    
    self = conf.p
    irq_timer, irq_ebreak, irq_buserror = 0, 1, 2 
    irqregs_offset = 32 if self.ENABLE_REGS_16_31 else 16 
    regfile_size = irqregs_offset + 4*self.ENABLE_IRQ*self.ENABLE_IRQ_QREGS 
    regindex_bits = (5 if self.ENABLE_REGS_16_31 else 4) + self.ENABLE_IRQ*self.ENABLE_IRQ_QREGS 
    self.WITH_PCPI = self.ENABLE_PCPI or self.ENABLE_MUL or self.ENABLE_FAST_MUL or self.ENABLE_DIV 
     
    self.TRACE_BRANCH = 0b0001 << 32 
    self.TRACE_ADDR = 0b0010 << 32 
    self.TRACE_IRQ = 0b1000 << 32 
     
    count_cycle, count_instr = UInt(0, w=64), UInt(0, w=64)
    reg_pc, reg_next_pc, reg_op1, reg_op2, reg_out = (UInt(0, w=32) for _ in range(5))
    reg_sh = UInt(0, w=5)

    next_insn_opcode = UInt(0, w=32)
    dbg_insn_opcode = UInt(0, w=32)
    dbg_insn_addr = UInt(0, w=32) 

    dbg_mem_valid = WireNext(io.mem.valid)
    dbg_mem_instr = WireNext(io.mem.instr)
    dbg_mem_ready = WireNext(io.mem.ready) 
    dbg_mem_addr = WireNext(io.mem.addr)
    dbg_mem_wdata = WireNext(io.mem.wdata)
    dbg_mem_wstrb = WireNext(io.mem.wstrb)
    dbg_mem_rdata = WireNext(io.mem.rdata) 

    io.pcpi.rs1 <== reg_op1 
    io.pcpi.rs2 <== reg_op2 

    next_pc = UInt(0, w=32)
    irq_delay = UInt(0)
    irq_active = UInt(0)
    irq_mask = UInt(0, w=32)
    irq_pending = UInt(0, w=32)
    timer = UInt(0, w=32)  

    if not self.PICORV32_REGS:
        cpuregs = Mem( (UInt[32]**regfile_size)(0) )
    if self.DEBUGREGS:
        dbg_reg = Array([])
        for i in range(32):
            dbg_reg[f'x{i}'] = cpuregs[i]

    pcpi_io = lambda : Bundle(
        wr = UInt(0), 
        rd = UInt(0, w=32), 
        wait = UInt(0), 
        ready = UInt(0),
    )
    # Internal PCPI Cores 
    pcpi_mul = pcpi_io()
    pcpi_div = pcpi_io()
    pcpi_int = pcpi_io()

    # TODO mul, div
    pcpi_mul <== 0 
    pcpi_div <== 0 
    pcpi_int <== 0 

    


    

@module Picorv32_regs:
    io = Bundle(
        wen = UInt(0) @ Input, 
        waddr = UInt(0, w=6) @ Input, 
        raddr1 = UInt(0, w=6) @ Input, 
        raddr2 = UInt(0, w=6) @ Input, 
        wdata = UInt(0, w=32) @ Input, 
        rdata1 = UInt(0, w=32) @ Output, 
        rdata2 = UInt(0, w=32) @ Output,
    ) 
    reg_t = UInt[32] ** 32 
    regs = Mem(reg_t(0))
    when io.wen: 
        regs[~io.waddr[:5]] <== io.wdata 
    io.rdata1 <== regs[~io.raddr1[:5]] 
    io.rdata2 <== regs[~io.raddr2[:5]]


with Session(PicoConfig()) as sess:
    dut = Picorv32()
    sess.dumpVerilog('target/picorv32.sv')
